---
title: JS编码规范
date: 2019-04-16 11:10:54
tags: javascript
---

http://gitlab.baidu.com/fe/spec/blob/master/javascript.md

## JavaScript编码规范

### 代码风格

#### 文件

```
1. JavaScript 文件使用无 BOM 的 UTF-8 编码。

2. 在文件结尾处，保留一个空行
```


#### 结构

1. 缩进
   - 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。
   - switch 下的 case 和 default 必须增加一个缩进层级。
2. 空格
   - 二元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。
   - 用作代码块起始的左花括号 { 前必须有一个空格。
   - if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格
   - 在对象创建时，属性中的 : 之后必须有空格，: 之前不允许有空格。
   - 函数声明、具名函数表达式、函数调用中，函数名和 ( 之间不允许有空格。
   - , 和 ; 前不允许有空格。如果不位于行尾，, 和 ; 后必须跟一个空格。
   - 在函数调用、函数声明、括号表达式、属性访问、if / for / while / switch / catch 等语句中，() 和 [] 内紧贴括号部分不允许有空格。
   - 单行声明的数组与对象，如果包含元素，{} 和 [] 内紧贴括号部分不允许包含空格。
3. 换行
   - 每个独立语句结束后必须换行。
   - 每行不得超过 120 个字符。
   - 运算符处换行时，运算符必须在新行的行首。
   - 在函数声明、函数表达式、函数调用、对象创建、数组创建、for 语句等场景中，不允许在 , 或 ; 前换行。
   - 不同行为或逻辑的语句集，使用空行隔开，更易阅读。
   - 在语句的行长度超过 120 时，根据逻辑条件合理缩进。
   - 对于 if…else…、try…catch…finally 等语句，推荐使用在 } 号后添加一个换行 的风格，使代码层次结构更清晰，阅读性更好。
4. 语句
   - 不得省略语句结束的分号
   - 在 if / else / for / do / while 语句中，即使只有一行，也不得省略块 {…}。
   - 函数定义结束不允许添加分号。
   - IIFE 必须在函数表达式外添加 (，非 IIFE 不得在函数表达式外添加 (。
     - IIFE = Immediately-Invoked Function Expression.
     - 额外的 ( 能够让代码在阅读的一开始就能判断函数是否立即被调用，进而明白接下来代码的用途。而不是一直拖到底部才恍然大悟。

#### 命名

- 变量 使用 Camel命名法。如：var HTML_ENTITY = {};

- 常量 使用 全部字母大写，单词间下划线分隔 的命名方式。如：var HTML_ENTITY = {};

- 函数 使用 Camel命名法。如：function stringFormat(source) { … }

- 函数的 参数 使用 Camel命名法。

- 类 使用 Pascal命名法。function TextNode(options) {…}

- 类的 方法 / 属性 使用 Camel命名法。

- 枚举变量 使用 Pascal命名法，枚举的属性 使用 全部字母大写，单词间下划线分隔 的命名方式。

  ```
  var TargetState = {
      READING: 1,
      READED: 2,
      APPLIED: 3,
      READY: 4
  };
  ```

- 命名空间 使用 Camel命名法。

- 由多个单词组成的缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。

- 类名使用名词

- 函数名使用动宾短语

- boolean类型的变量使用is或has开头

- Promise对象用动宾短语的进行时表达

#### 注释

1. 单行注释：

   必须独占一行。// 后跟一个空格，缩进与下一行被注释说明的代码一致。

2. 多行注释：

   避免使用 /*…*/ 这样的多行注释。有多行注释内容时，使用多个单行注释。

3. 文档化注释

   - 为了便于代码阅读和自文档化，以下内容必须包含以 /**…*/ 形式的块注释中。
     - 文件
     - namespace
     - 类
     - 函数或方法
     - 类属性
     - 事件
     - 全局变量
     - 常量
     - AMD 模块
   - 文档注释前必须空一行。
   - 自文档化的文档说明 what，而不是 how。

4. 类型定义

   - 类型定义都是以 { 开始, 以 } 结束。
     - 常用类型如：{string}, {number}, {boolean}, {Object}, {Function}, {RegExp}, {Array}, {Date}。
     - 类型不仅局限于内置的类型，也可以是自定义的类型。比如定义了一个类 Developer，就可以使用它来定义一个参数和返回值的类型。
       - String {string} –
       - 单一类型集合 {Array.} string 类型的数组

5. 文件注释

   - 文件顶部必须包含文件注释，用 @file 标识文件说明。

     ```
     /**
      * @file Describe the file
      */
     ```

   - 文件注释中可以用 @author 标识开发者信息。

6. 命名空间注释

   - 命名空间使用 @namespace 标识。

     ```
     /**
      * @namespace
      */
     ```

7. 类注释

   - 使用 @class 标记类或构造函数。
     - 对于使用对象 constructor 属性来定义的构造函数，可以使用 @constructor 来标记。
   - 使用 @extends 标记类的继承信息。
   - 使用包装方式扩展类成员时， 必须通过 @lends 进行重新指向。
   - 类的属性或方法等成员信息不是 public 的，应使用 @protected 或 @private 标识可访问性。

8. 函数/方法注释

   - 函数/方法注释必须包含函数说明，有参数和返回值时必须使用注释标识。
   - 参数和返回值注释必须包含类型信息，且不允许省略参数的说明。
   - 当函数是内部函数，外部不可访问时，可以使用 @inner 标识。
   - 对 Object 中各项的描述， 必须使用 @param 标识。
   - 重写父类方法时， 应当添加 @override 标识。如果重写的形参个数、类型、顺序和返回值类型均未发生变化，可省略 @param、@return，仅用 @override 标识，否则仍应作完整注释。
     - 当子类重写的方法能直接套用父类的方法注释时可省略对参数与返回值的注释。

9. 事件注释

   - 必须使用 @event 标识事件，事件参数的标识与方法描述的参数标识相同。
   - 在会广播事件的函数前使用 @fires 标识广播的事件，在广播事件代码前使用 @event 标识事件。
   - 对于事件对象的注释，使用 @param 标识，生成文档时可读性更好。

10. 常量注释

    - 常量必须使用 @const 标识，并包含说明和类型信息

11. 复杂类型注释

    - 对于类型未定义的复杂结构的注释，可以使用 @typedef 标识来定义。

12. AMD 模块注释

    - AMD 模块使用 @module 或 @exports 标识。
      - @exports 与 @module 都可以用来标识模块，区别在于 @module 可以省略模块名称。而只使用 @exports 时在 namepaths 中可以省略 module: 前缀。
    - 对于已使用 @module 标识为 AMD模块 的引用，在 namepaths 中必须增加 module: 作前缀。
    - 对于类定义的模块，可以使用 @alias 标识构建函数。
    - 多模块定义时，可以使用 @exports 标识各个模块。
    - 对于 exports 为 Object 的模块，可以使用@namespace标识。
    - 对于 exports 为类名的模块，使用 @class 和 @exports 标识。

13. 细节注释

    - 细节注释遵循单行注释的格式。说明必须换行时，每行是一个单行注释的起始。
    - 有时我们会使用一些特殊标记进行说明。特殊标记必须使用单行注释的形式。下面列举了一些常用标记：
      1. TODO: 有功能待实现。此时需要对将要实现的功能进行简单说明。
      2. FIXME: 该处代码运行没问题，但可能由于时间赶或者其他原因，需要修正。此时需要对如何修正进行简单说明。
      3. HACK: 为修正某些问题而写的不太好或者使用了某些诡异手段的代码。此时需要对思路或诡异手段进行描述。
      4. XXX: 该处存在陷阱。此时需要对陷阱进行描述。

### 语言特性

#### 变量

```
1. 变量、函数在使用前必须先定义。

    - 原则上不建议使用全局变量，对于已有的全局变量或第三方框架引入的全局变量，需要根据检查工具的语法标识。

    - 不通过 var 定义变量将导致变量污染全局环境。

2. 每个 var 只能声明一个变量。

3. 变量必须 即用即声明，不得在函数或其它形式的代码块起始位置统一声明所有变量。
```

#### 条件

1. 在 Equality Expression 中使用类型严格的 ===。仅当判断 null 或 undefined 时，允许使用 == null
   - 使用 === 可以避免等于判断中隐式的类型转换。
2. 尽可能使用简洁的表达式。如：if (!name){} 优于 if (name === ‘’){}
3. 按执行频率排列分支的顺序。
   - 按执行频率排列分支的顺序好处是：
     - 阅读的人容易找到最常见的情况，增加可读性。
     - 提高执行效率。
4. 对于相同变量或表达式的多值条件，用 switch 代替 if。
5. 如果函数或全局中的 else 块后没有任何语句，可以删除 else。

#### 循环

1. 不要在循环体中包含函数表达式，事先将函数提取到循环体外。

   - 循环体中的函数表达式，运行过程中会生成循环次数个函数对象。

     ```js
     // good
     function clicker() {
         // ......
     }
     for (var i = 0, len = elements.length; i < len; i++) {
         var element = elements[i];
         addListener(element, 'click', clicker);
     }
     
     
     // bad
     for (var i = 0, len = elements.length; i < len; i++) {
         var element = elements[i];
         addListener(element, 'click', function () {});
     }
     ```

2. 对循环内多次使用的不变值，在循环外用变量缓存。

3. 对有序集合进行遍历时，缓存 length。

   - 虽然现代浏览器都对数组长度进行了缓存，但对于一些宿主对象和老旧浏览器的数组对象，在每次 length 访问时会动态计算元素个数，此时缓存 length 能有效提高程序性能。

4. 对有序集合进行顺序无关的遍历时，使用逆序遍历。

   - 逆序遍历可以节省变量，代码比较优化。

    ```js
    // good
    var len = elements.length;
    while (len--) {
        var element = elements[len];
        // ......
    }
    ```


#### 类型

1. 类型检测
   - 类型检测优先使用 typeof。对象类型检测使用 instanceof。null 或 undefined 的检测使用 == null。
2. 类型转换
   - 转换成 string 时，使用 + ‘’。
   - 转换成 number 时，通常使用 +。
   - string 转换成 number，要转换的字符串结尾包含非数字并期望忽略时，使用 parseInt。
     - PS: var width = ‘200px’; parseInt(width, 10);
   - 使用 parseInt 时，必须指定进制。
   - 转换成 boolean 时，使用 !!。
   - number 去除小数点，使用 Math.floor / Math.round / Math.ceil，不使用 parseInt。

#### 字符串

- 字符串开头和结束使用单引号 ‘。

  - 输入单引号不需要按住 shift，方便输入。
  - 实际使用中，字符串经常用来拼接 HTML。为方便 HTML 中包含双引号而不需要转义写法。

- 使用 数组 或 + 拼接字符串。

- 使用字符串拼接的方式生成HTML，需要根据语境进行合理的转义。

  - 在 JavaScript 中拼接，并且最终将输出到页面中的字符串，需要进行合理转义，以防止安全漏洞。

- 复杂的数据到视图字符串的转换过程，选用一种模板引擎。

  使用模板引擎有如下好处：

  - 在开发过程中专注于数据，将视图生成的过程由另外一个层级维护，使程序逻辑结构更清晰。
  - 优秀的模板引擎，通过模板编译技术和高质量的编译产物，能获得比手工拼接字符串更高的性能。
  - 模板引擎能方便的对动态数据进行相应的转义，部分模板引擎默认进行HTML转义，安全性更好。

  1. artTemplate: 体积较小，在所有环境下性能高，语法灵活。
  2. dot.js: 体积小，在现代浏览器下性能高，语法灵活。
  3. etpl: 体积较小，在所有环境下性能高，模板复用性高，语法灵活。
  4. handlebars: 体积大，在所有环境下性能高，扩展性高。
  5. hogon: 体积小，在现代浏览器下性能高。
  6. nunjucks: 体积较大，性能一般，模板复用性高。

#### 对象

- 使用对象字面量 {} 创建新 Object。

- 对象创建时，如果一个对象的所有 属性 均可以不添加引号，建议所有 属性 不添加引号。

- 对象创建时，如果任何一个 属性 需要添加引号，则所有 属性 建议添加 ‘。

  - 如果属性不符合 Identifier 和 NumberLiteral 的形式，就需要以 StringLiteral 的形式提供。

- 不允许修改和扩展任何原生对象和宿主对象的原型。

- 属性访问时，尽量使用 .。

  - 属性名符合 Identifier 的要求，就可以通过 . 来访问，否则就只能通过 [expr] 方式访问。

- for in 遍历对象时, 使用 hasOwnProperty 过滤掉原型中的属性。

    ```js
    var newInfo = {};
    for (var key in info) {
        if (info.hasOwnProperty(key)) {
            newInfo[key] = info[key];
        }
    }
    ```

#### 数组

- 使用数组字面量 [] 创建新数组，除非想要创建的是指定长度的数组。
- 遍历数组不使用 for in。
  - 数组对象可能存在数字意外的属性，这种情况下for in 不会得到正确的结果
- 不因为性能的原因自己实现数组排序功能，尽量使用数组的sort方法
  - 自己实现的常规排序算法，在性能上并不优于数组默认的sort方法。以下场景可以自己实现排序:
    1. 需要稳定的排序算法，达到严格一致的排序结果。
    2. 数据特点鲜明，适合使用桶排。
- 清空数组使用 .length = 0。

#### 函数

1. 函数长度
   - 一个函数的长度控制在50行以内
     - 将过多的逻辑单元混在一个大函数中，易导致难以维护。一个清晰易懂的函数应该完成单一的逻辑单元。复杂的操作应进一步抽取，通过函数的调用来体现流程。
     - 特定算法等不可分割的逻辑允许例外。
2. 参数设计
   - 一个函数的参数控制在 6 个以内。
     - 除去不定长参数以外，函数具备不同逻辑意义的参数建议控制在 6 个以内，过多参数会导致维护难度增大。
     - 某些情况下，如使用 AMD Loader 的 require 加载多个模块时，其 callback 可能会存在较多参数，因此对函数参数的个数不做强制限制。
   - 通过 options 参数传递非数据输入型参数。
     - 有些函数的参数并不是作为算法的输入，而是对算法的某些分支条件判断之用，此类参数建议通过一个 options 参数传递。
3. 闭包
   - 在适当的时候将闭包内大对象置为 null。
     - 在JS中，无需特别的关键词就可以使用闭包，一个函数可以任意访问在其定义的作用于外的变量。需要注意的是，函数的作用域是静态的，即在定义时决定，与调用的时机和方式没有任何关系。
     - 闭包会阻止一些变量的垃圾回收，对于较老旧的 JavaScript 引擎，可能导致外部所有变量均无法回收。
     - 首先一个较为明确的结论是，以下内容会影响到闭包内变量的回收：
       - 嵌套的函数中是否有使用该变量。
       - 嵌套的函数中是否有 直接调用eval。
       - 是否使用了 with 表达式。
4. 空函数
   - 空函数不使用 new Function() 的形式。
   - 对于性能有高要求的场合，建议存在一个空函数的常量，供多处使用共享。

#### 面向对象

- 类的继承方案，实现时需要修正 constructor。

```
/*
构建类之间的继承关系
*/
function inherits(subClass, superClass) {
    var F = new Function();
    F.prototype = superClass.prototype;
    subClass.prototype = new F();
    subClass.prototype.constructor = subClass;
}
```

- 声明类时，保证constructor的正确性
- 属性在构造函数中声明，方法在原型中声明。
  - 原型对象的成员被所有实例共享，能节约内存占用。所以编码时我们应该遵守这样的原则：原型对象包含程序不会修改的成员，如方法函数或配置项。
- 自定义事件的 事件名 必须全小写。
  - 在 JavaScript 广泛应用的浏览器环境，绝大多数 DOM 事件名称都是全小写的。为了遵
    循大多数 JavaScript 开发者的习惯，在设计自定义事件时，事件名也应该全小写。
- 自定义事件只能有一个 event 参数。如果事件需要传递较多信息，应仔细设计事件对象。
  - 一个事件对象的好处有：
    1. 顺序无关，避免事件监听者需要记忆参数顺序。
    2. 每个事件信息都可以根据需要提供或者不提供，更自由。
    3. 扩展方便，未来添加事件信息时，无需考虑会破坏监听器参数形式而无法向后兼容。
- 设计自定义事件时，应考虑禁止默认行为。
  - 常见禁止默认行为的方式有两种：
    - 事件监听函数中 return false。
    - 事件对象中包含禁止默认行为的方法，如 preventDefault。

#### 动态特性

1. eval
   - 避免使用直接 eval 函数。
     - 直接 eval，指的是以函数方式调用 eval 的调用方法。直接 eval 调用执行代码的作用域为本地作用域，应当避免。
   - 尽量避免使用 eval 函数。
2. 动态执行代码
   - 使用 new Function 执行动态代码。
     - 通过 new Function 生成的函数作用域是全局使用域，不会影响当当前的本地作用域。如果有动态代码执行的需求，建议使用 new Function。
3. with
   - 尽量不要使用 with。
4. delete
   - 减少 delete 的使用。（如果没有特别的需求，减少或避免使用 delete。delete 的使用会破坏部分 JavaScript 引擎的性能优化。）
   - 处理 delete 可能产生的异常。
     - 对于有被遍历需求，且值 null 被认为具有业务逻辑意义的值的对象，移除某个属性必须使用 delete 操作。
     - 在严格模式或 IE 下使用 delete 时，不能被删除的属性会抛出异常，因此在不确定属性是否可以删除的情况下，建议添加 try-catch 块。
5. 对象属性
   - 避免修改外部传入的对象
     - JavaScript 因其脚本语言的动态特性，当一个对象未被 seal 或 freeze 时，可以任意添加、删除、修改属性值。
     - 但是随意地对 非自身控制的对象 进行修改，很容易造成代码在不可预知的情况下出现问题
   - 具备强类型的设计。