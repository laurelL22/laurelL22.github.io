<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="desc">
<meta name="keywords" content="keyword">
<meta property="og:type" content="website">
<meta property="og:title" content="Laurel Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Laurel Blog">
<meta property="og:description" content="desc">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Laurel Blog">
<meta name="twitter:description" content="desc">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Laurel Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Laurel Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">许多年前，曾是个朴素的少年</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/Code-Snippet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lurel">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laurel Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/22/Code-Snippet/" itemprop="url">Code-Snippet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-22T16:58:17+08:00">
                2019-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index">
                    <span itemprop="name">interview</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Agenda"><a href="#Agenda" class="headerlink" title="Agenda"></a>Agenda</h3><ul>
<li>实现Promise</li>
<li>实现promiseAll</li>
<li>实现bind</li>
<li>实现数据劫持</li>
<li>最大公共子串</li>
</ul>
<h3 id="实现Promise"><a href="#实现Promise" class="headerlink" title="实现Promise"></a>实现Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    _this.currentState = PENDING;</span><br><span class="line">    _this.value = <span class="literal">undefined</span>;</span><br><span class="line">    _this.resolvedCallbacks = [];</span><br><span class="line">    _this.rejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = RESOLVED;</span><br><span class="line">                _this.value = value;</span><br><span class="line">                _this.resolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = REJECTED;</span><br><span class="line">                _this.value = reason;</span><br><span class="line">                _this.rejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fn(_this.resolve, _this.reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        _this.reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFullfilled,onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">switch</span>(_this.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"pending"</span>:</span><br><span class="line">            _this.onFullfilledArray.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                onFullfilled(_this.value)</span><br><span class="line">            &#125;);</span><br><span class="line">            _this.onRejectedArray.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                onRejected(_this.reason)</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'resolved'</span>:</span><br><span class="line">            onFullfilled(_this.value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'rejected'</span>:</span><br><span class="line">            onRejected(_this.reason);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现promiseAll"><a href="#实现promiseAll" class="headerlink" title="实现promiseAll"></a>实现promiseAll</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseAll</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(promises)) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'argument must be array'</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> countNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> promiseLength = promises.length;</span><br><span class="line">        <span class="keyword">var</span> resolvedvalue = <span class="keyword">new</span> <span class="built_in">Array</span>(promiseNum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; promises; i++) &#123;</span><br><span class="line">            (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">Promise</span>.resolve(promise[i]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">                    countNum++;</span><br><span class="line">                    resolvedvalue[i] = value;</span><br><span class="line">                    <span class="keyword">if</span> (countNum === promiseNum) &#123;</span><br><span class="line">                        <span class="keyword">return</span> resolve(resolvedvalue)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> reject(reason);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现bind"><a href="#实现bind" class="headerlink" title="实现bind"></a>实现bind</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    arg = args.concat(...arguments);</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, arg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 寄生式继承</span></span><br><span class="line">  F.prototype = _this.prototype;</span><br><span class="line">  bound.prototype = <span class="keyword">new</span> F();</span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过Object.defineProperty对具体实例中的data实现代理，在get里面实现依赖收集，(每个数据都被生成一个Watcher实例，推进到Dep实例中)都推到一个Dep实例的subs数组里面，并将具体data里面的数据打上标记，表示是要实现响应式的数据;在set里面实现回调，当数据值发生变化的时候，Dep的notify方法会被调用，notice方法中会调用Watcher类的update方法，对具体数据进行更新操作，并调用render方法，将dom局部进行重新渲染更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue内部使用Object.defineProperty()来实现双向绑定，通过这个函数可以监听到set和 get的事件</span></span><br><span class="line"><span class="comment">// 实现一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        defineReactive(obj, key, obj[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 递归子属性</span></span><br><span class="line">    observe(val)</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'get value'</span>);</span><br><span class="line">            <span class="comment">// 将Watcher添加到订阅</span></span><br><span class="line">            <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                dp.addSub(Dep.target)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'set value'</span>);</span><br><span class="line">            val = newValue</span><br><span class="line">            <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">            dp.notify()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Dep解耦</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(sub) &#123; <span class="comment">// 依赖收集,推到Dep实例的subs数组里面</span></span><br><span class="line">        <span class="comment">// sub是Watcher实例</span></span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">    notify() &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.update())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置Watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(obj, key, cb) &#123;</span><br><span class="line">        Dep.target = <span class="keyword">this</span> <span class="comment">// 将Dep.target指向自己</span></span><br><span class="line">        <span class="keyword">this</span>.cb = cb</span><br><span class="line">        <span class="keyword">this</span>.obj = obj</span><br><span class="line">        <span class="keyword">this</span>.key = key</span><br><span class="line">        <span class="keyword">this</span>.value = obj[key] <span class="comment">// 然后触发属性的getter添加监听</span></span><br><span class="line">        Dep.target = <span class="literal">null</span> <span class="comment">// 最后将Dep.target置空</span></span><br><span class="line">    &#125;</span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="comment">// 获得新值</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key]</span><br><span class="line">        <span class="comment">// 调用update方法更新Dom</span></span><br><span class="line">        <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// call</span></span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">new</span> Watcher(data, <span class="string">'name'</span>, update) <span class="comment">// data数据生成一个Watcher实例</span></span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br></pre></td></tr></table></figure>
<h3 id="JS-实现DOM对象"><a href="#JS-实现DOM对象" class="headerlink" title="JS 实现DOM对象"></a>JS 实现DOM对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(tag, props, children, key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.tag = tag</span><br><span class="line">        <span class="keyword">this</span>.props = props</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.children = children <span class="comment">// 给每个节点一个标识，作为判断是同一个节点的依据</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isString(children)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = chidlren</span><br><span class="line">            <span class="keyword">this</span>.chidlren = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key) <span class="keyword">this</span>.key = key</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 渲染</span></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">let</span> root = <span class="keyword">this</span>._createElement(</span><br><span class="line">            <span class="keyword">this</span>.tag,</span><br><span class="line">            <span class="keyword">this</span>.props,</span><br><span class="line">            <span class="keyword">this</span>.children,</span><br><span class="line">            <span class="keyword">this</span>.key</span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    create() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._createElement(<span class="keyword">this</span>.tag, <span class="keyword">this</span>.props, <span class="keyword">this</span>.children, <span class="keyword">this</span>.key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建节点</span></span><br><span class="line">    _createElement(tag, props, child, key) &#123;</span><br><span class="line">        <span class="comment">// 通过tag创建节点</span></span><br><span class="line">        <span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(tag)</span><br><span class="line">        <span class="comment">// 设置节点属性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">            <span class="keyword">if</span> (props.hasOwnProperty(key)) &#123;</span><br><span class="line">                <span class="keyword">const</span> value = props[key]</span><br><span class="line">                el.setAttribute(key, value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key) &#123;</span><br><span class="line">            el.setAttribute(<span class="string">'key'</span>, key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归添加子节点</span></span><br><span class="line">        <span class="keyword">if</span> (child) &#123;</span><br><span class="line">            child.forEach(<span class="function"><span class="params">ele</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> child</span><br><span class="line">                <span class="keyword">if</span> (ele <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                    child = <span class="keyword">this</span>._createElement(</span><br><span class="line">                        ele.tag,</span><br><span class="line">                        ele.props,</span><br><span class="line">                        ele.children,</span><br><span class="line">                        ele.key</span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 文本节点</span></span><br><span class="line">                    child = <span class="built_in">document</span>.createTextNode(ele)</span><br><span class="line">                &#125;</span><br><span class="line">                el.appendChild(child)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> el</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大公共子串"><a href="#最大公共子串" class="headerlink" title="最大公共子串"></a>最大公共子串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findSubStr</span>(<span class="params">str1, str2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str1.length &gt; str2.length) &#123;</span><br><span class="line">      <span class="keyword">var</span> temp = str1;</span><br><span class="line">      str1 = str2;</span><br><span class="line">      str2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> len1 = str1.length,</span><br><span class="line">      len2 = str2.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = len1; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len2 - j; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> current = str1.substr(i, j);</span><br><span class="line">        <span class="keyword">if</span> (str2.indexOf(current) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code class="javascript">
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/16/JS编码规范/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lurel">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laurel Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/16/JS编码规范/" itemprop="url">JS编码规范</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-16T17:32:53+08:00">
                2019-04-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://gitlab.baidu.com/fe/spec/blob/master/javascript.md" target="_blank" rel="noopener">http://gitlab.baidu.com/fe/spec/blob/master/javascript.md</a></p>
<h2 id="JavaScript编码规范"><a href="#JavaScript编码规范" class="headerlink" title="JavaScript编码规范"></a>JavaScript编码规范</h2><h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><pre><code>1. JavaScript 文件使用无 BOM 的 UTF-8 编码。

2. 在文件结尾处，保留一个空行
</code></pre><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ol>
<li><p>缩进</p>
<ul>
<li><p>使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。</p>
</li>
<li><p>switch 下的 case 和 default 必须增加一个缩进层级。</p>
</li>
</ul>
</li>
<li><p>空格</p>
<ul>
<li><p>二元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。</p>
</li>
<li><p>用作代码块起始的左花括号 { 前必须有一个空格。</p>
</li>
<li><p>if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格</p>
</li>
<li><p>在对象创建时，属性中的 : 之后必须有空格，: 之前不允许有空格。</p>
</li>
<li><p>函数声明、具名函数表达式、函数调用中，函数名和 ( 之间不允许有空格。</p>
</li>
<li><p>, 和 ; 前不允许有空格。如果不位于行尾，, 和 ; 后必须跟一个空格。</p>
</li>
<li><p>在函数调用、函数声明、括号表达式、属性访问、if / for / while / switch / catch 等语句中，() 和 [] 内紧贴括号部分不允许有空格。</p>
</li>
<li><p>单行声明的数组与对象，如果包含元素，{} 和 [] 内紧贴括号部分不允许包含空格。</p>
</li>
</ul>
</li>
<li><p>换行</p>
<ul>
<li><p>每个独立语句结束后必须换行。</p>
</li>
<li><p>每行不得超过 120 个字符。</p>
</li>
<li><p>运算符处换行时，运算符必须在新行的行首。</p>
</li>
<li><p>在函数声明、函数表达式、函数调用、对象创建、数组创建、for 语句等场景中，不允许在 , 或 ; 前换行。</p>
</li>
<li><p>不同行为或逻辑的语句集，使用空行隔开，更易阅读。</p>
</li>
<li><p>在语句的行长度超过 120 时，根据逻辑条件合理缩进。</p>
</li>
<li><p>对于 if…else…、try…catch…finally 等语句，推荐使用在 } 号后添加一个换行 的风格，使代码层次结构更清晰，阅读性更好。</p>
</li>
</ul>
</li>
<li><p>语句</p>
<ul>
<li><p>不得省略语句结束的分号</p>
</li>
<li><p>在 if / else / for / do / while 语句中，即使只有一行，也不得省略块 {…}。</p>
</li>
<li><p>函数定义结束不允许添加分号。</p>
</li>
<li><p>IIFE 必须在函数表达式外添加 (，非 IIFE 不得在函数表达式外添加 (。</p>
<ul>
<li><p>IIFE = Immediately-Invoked Function Expression.</p>
</li>
<li><p>额外的 ( 能够让代码在阅读的一开始就能判断函数是否立即被调用，进而明白接下来代码的用途。而不是一直拖到底部才恍然大悟。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ul>
<li><p>变量 使用 Camel命名法。如：var HTML_ENTITY = {};</p>
</li>
<li><p>常量 使用 全部字母大写，单词间下划线分隔 的命名方式。如：var HTML_ENTITY = {};</p>
</li>
<li><p>函数 使用 Camel命名法。如：function stringFormat(source) { … }</p>
</li>
<li><p>函数的 参数 使用 Camel命名法。</p>
</li>
<li><p>类 使用 Pascal命名法。function TextNode(options) {…}</p>
</li>
<li><p>类的 方法 / 属性 使用 Camel命名法。</p>
</li>
<li><p>枚举变量 使用 Pascal命名法，枚举的属性 使用 全部字母大写，单词间下划线分隔 的命名方式。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TargetState = &#123;</span><br><span class="line">    READING: <span class="number">1</span>,</span><br><span class="line">    READED: <span class="number">2</span>,</span><br><span class="line">    APPLIED: <span class="number">3</span>,</span><br><span class="line">    READY: <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命名空间 使用 Camel命名法。</p>
</li>
<li><p>由多个单词组成的缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。</p>
</li>
<li><p>类名使用名词</p>
</li>
<li><p>函数名使用动宾短语</p>
</li>
<li><p>boolean类型的变量使用is或has开头</p>
</li>
<li><p>Promise对象用动宾短语的进行时表达</p>
</li>
</ul>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ol>
<li><p>单行注释：</p>
<p> 必须独占一行。// 后跟一个空格，缩进与下一行被注释说明的代码一致。</p>
</li>
<li><p>多行注释：</p>
<p> 避免使用 /<em>…</em>/ 这样的多行注释。有多行注释内容时，使用多个单行注释。</p>
</li>
<li><p>文档化注释</p>
<ul>
<li><p>为了便于代码阅读和自文档化，以下内容必须包含以 /*<em>…</em>/ 形式的块注释中。</p>
<ul>
<li>文件</li>
<li>namespace</li>
<li>类</li>
<li>函数或方法</li>
<li>类属性</li>
<li>事件</li>
<li>全局变量</li>
<li>常量</li>
<li>AMD 模块</li>
</ul>
</li>
<li><p>文档注释前必须空一行。</p>
</li>
<li><p>自文档化的文档说明 what，而不是 how。</p>
</li>
</ul>
</li>
<li><p>类型定义</p>
<ul>
<li><p>类型定义都是以 { 开始, 以 } 结束。</p>
<ul>
<li><p>常用类型如：{string}, {number}, {boolean}, {Object}, {Function}, {RegExp}, {Array}, {Date}。</p>
</li>
<li><p>类型不仅局限于内置的类型，也可以是自定义的类型。比如定义了一个类 Developer，就可以使用它来定义一个参数和返回值的类型。</p>
<ul>
<li>String  {string}  –</li>
<li>单一类型集合  {Array.<string>}  string 类型的数组</string></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>文件注释</p>
<ul>
<li><p>文件顶部必须包含文件注释，用 @file 标识文件说明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file Describe the file</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文件注释中可以用 @author 标识开发者信息。</p>
</li>
</ul>
</li>
<li><p>命名空间注释</p>
<ul>
<li><p>命名空间使用 @namespace 标识。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @namespace</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>类注释</p>
<ul>
<li><p>使用 @class 标记类或构造函数。</p>
<ul>
<li>对于使用对象 constructor 属性来定义的构造函数，可以使用 @constructor 来标记。</li>
</ul>
</li>
<li><p>使用 @extends 标记类的继承信息。</p>
</li>
<li><p>使用包装方式扩展类成员时， 必须通过 @lends 进行重新指向。</p>
</li>
<li><p>类的属性或方法等成员信息不是 public 的，应使用 @protected 或 @private 标识可访问性。</p>
</li>
</ul>
</li>
<li><p>函数/方法注释</p>
<ul>
<li><p>函数/方法注释必须包含函数说明，有参数和返回值时必须使用注释标识。</p>
</li>
<li><p>参数和返回值注释必须包含类型信息，且不允许省略参数的说明。</p>
</li>
<li><p>当函数是内部函数，外部不可访问时，可以使用 @inner 标识。</p>
</li>
<li><p>对 Object 中各项的描述， 必须使用 @param 标识。</p>
</li>
<li><p>重写父类方法时， 应当添加 @override 标识。如果重写的形参个数、类型、顺序和返回值类型均未发生变化，可省略 @param、@return，仅用 @override 标识，否则仍应作完整注释。</p>
<ul>
<li>当子类重写的方法能直接套用父类的方法注释时可省略对参数与返回值的注释。</li>
</ul>
</li>
</ul>
</li>
<li><p>事件注释</p>
<ul>
<li><p>必须使用 @event 标识事件，事件参数的标识与方法描述的参数标识相同。</p>
</li>
<li><p>在会广播事件的函数前使用 @fires 标识广播的事件，在广播事件代码前使用 @event 标识事件。</p>
</li>
<li><p>对于事件对象的注释，使用 @param 标识，生成文档时可读性更好。</p>
</li>
</ul>
</li>
<li><p>常量注释</p>
<ul>
<li>常量必须使用 @const 标识，并包含说明和类型信息</li>
</ul>
</li>
<li><p>复杂类型注释</p>
<ul>
<li>对于类型未定义的复杂结构的注释，可以使用 @typedef 标识来定义。</li>
</ul>
</li>
<li><p>AMD 模块注释</p>
<ul>
<li><p>AMD 模块使用 @module 或 @exports 标识。</p>
<ul>
<li>@exports 与 @module 都可以用来标识模块，区别在于 @module 可以省略模块名称。而只使用 @exports 时在 namepaths 中可以省略 module: 前缀。</li>
</ul>
</li>
<li><p>对于已使用 @module 标识为 AMD模块 的引用，在 namepaths 中必须增加 module: 作前缀。</p>
</li>
<li><p>对于类定义的模块，可以使用 @alias 标识构建函数。</p>
</li>
<li><p>多模块定义时，可以使用 @exports 标识各个模块。</p>
</li>
<li><p>对于 exports 为 Object 的模块，可以使用@namespace标识。</p>
</li>
<li><p>对于 exports 为类名的模块，使用 @class 和 @exports 标识。</p>
</li>
</ul>
</li>
<li><p>细节注释</p>
<ul>
<li><p>细节注释遵循单行注释的格式。说明必须换行时，每行是一个单行注释的起始。</p>
</li>
<li><p>有时我们会使用一些特殊标记进行说明。特殊标记必须使用单行注释的形式。下面列举了一些常用标记：</p>
<ol>
<li>TODO: 有功能待实现。此时需要对将要实现的功能进行简单说明。</li>
<li>FIXME: 该处代码运行没问题，但可能由于时间赶或者其他原因，需要修正。此时需要对如何修正进行简单说明。</li>
<li>HACK: 为修正某些问题而写的不太好或者使用了某些诡异手段的代码。此时需要对思路或诡异手段进行描述。</li>
<li>XXX: 该处存在陷阱。此时需要对陷阱进行描述。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code>1. 变量、函数在使用前必须先定义。

    - 原则上不建议使用全局变量，对于已有的全局变量或第三方框架引入的全局变量，需要根据检查工具的语法标识。

    - 不通过 var 定义变量将导致变量污染全局环境。

2. 每个 var 只能声明一个变量。

3. 变量必须 即用即声明，不得在函数或其它形式的代码块起始位置统一声明所有变量。
</code></pre><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ol>
<li><p>在 Equality Expression 中使用类型严格的 ===。仅当判断 null 或 undefined 时，允许使用 == null</p>
<ul>
<li>使用 === 可以避免等于判断中隐式的类型转换。</li>
</ul>
</li>
<li><p>尽可能使用简洁的表达式。如：if (!name){} 优于 if (name === ‘’){}</p>
</li>
<li><p>按执行频率排列分支的顺序。</p>
<ul>
<li><p>按执行频率排列分支的顺序好处是：</p>
<ul>
<li>阅读的人容易找到最常见的情况，增加可读性。</li>
<li>提高执行效率。</li>
</ul>
</li>
</ul>
</li>
<li><p>对于相同变量或表达式的多值条件，用 switch 代替 if。</p>
</li>
<li><p>如果函数或全局中的 else 块后没有任何语句，可以删除 else。</p>
</li>
</ol>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><ol>
<li><p>不要在循环体中包含函数表达式，事先将函数提取到循环体外。</p>
<ul>
<li><p>循环体中的函数表达式，运行过程中会生成循环次数个函数对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clicker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = elements.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> element = elements[i];</span><br><span class="line">    addListener(element, <span class="string">'click'</span>, clicker);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = elements.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> element = elements[i];</span><br><span class="line">    addListener(element, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对循环内多次使用的不变值，在循环外用变量缓存。</p>
</li>
<li><p>对有序集合进行遍历时，缓存 length。</p>
<ul>
<li>虽然现代浏览器都对数组长度进行了缓存，但对于一些宿主对象和老旧浏览器的数组对象，在每次 length 访问时会动态计算元素个数，此时缓存 length 能有效提高程序性能。</li>
</ul>
</li>
<li><p>对有序集合进行顺序无关的遍历时，使用逆序遍历。</p>
<ul>
<li><p>逆序遍历可以节省变量，代码比较优化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> len = elements.length;</span><br><span class="line"><span class="keyword">while</span> (len--) &#123;</span><br><span class="line">    <span class="keyword">var</span> element = elements[len];</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ol>
<li><p>类型检测</p>
<ul>
<li>类型检测优先使用 typeof。对象类型检测使用 instanceof。null 或 undefined 的检测使用 == null。</li>
</ul>
</li>
<li><p>类型转换</p>
<ul>
<li><p>转换成 string 时，使用 + ‘’。</p>
</li>
<li><p>转换成 number 时，通常使用 +。</p>
</li>
<li><p>string 转换成 number，要转换的字符串结尾包含非数字并期望忽略时，使用 parseInt。</p>
<ul>
<li>PS: var width = ‘200px’; parseInt(width, 10);</li>
</ul>
</li>
<li><p>使用 parseInt 时，必须指定进制。</p>
</li>
<li><p>转换成 boolean 时，使用 !!。</p>
</li>
<li><p>number 去除小数点，使用 Math.floor / Math.round / Math.ceil，不使用 parseInt。</p>
</li>
</ul>
</li>
</ol>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li><p>字符串开头和结束使用单引号 ‘。</p>
<ul>
<li>输入单引号不需要按住 shift，方便输入。</li>
<li>实际使用中，字符串经常用来拼接 HTML。为方便 HTML 中包含双引号而不需要转义写法。</li>
</ul>
</li>
<li><p>使用 数组 或 + 拼接字符串。</p>
</li>
<li><p>使用字符串拼接的方式生成HTML，需要根据语境进行合理的转义。</p>
<ul>
<li>在 JavaScript 中拼接，并且最终将输出到页面中的字符串，需要进行合理转义，以防止安全漏洞。</li>
</ul>
</li>
<li><p>复杂的数据到视图字符串的转换过程，选用一种模板引擎。</p>
<p>  使用模板引擎有如下好处：</p>
<ul>
<li>在开发过程中专注于数据，将视图生成的过程由另外一个层级维护，使程序逻辑结构更清晰。</li>
<li>优秀的模板引擎，通过模板编译技术和高质量的编译产物，能获得比手工拼接字符串更高的性能。</li>
<li>模板引擎能方便的对动态数据进行相应的转义，部分模板引擎默认进行HTML转义，安全性更好。</li>
</ul>
<ol>
<li>artTemplate: 体积较小，在所有环境下性能高，语法灵活。</li>
<li>dot.js: 体积小，在现代浏览器下性能高，语法灵活。</li>
<li>etpl: 体积较小，在所有环境下性能高，模板复用性高，语法灵活。</li>
<li>handlebars: 体积大，在所有环境下性能高，扩展性高。</li>
<li>hogon: 体积小，在现代浏览器下性能高。</li>
<li>nunjucks: 体积较大，性能一般，模板复用性高。</li>
</ol>
</li>
</ul>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul>
<li><p>使用对象字面量 {} 创建新 Object。</p>
</li>
<li><p>对象创建时，如果一个对象的所有 属性 均可以不添加引号，建议所有 属性 不添加引号。</p>
</li>
<li><p>对象创建时，如果任何一个 属性 需要添加引号，则所有 属性 建议添加 ‘。</p>
<ul>
<li>如果属性不符合 Identifier 和 NumberLiteral 的形式，就需要以 StringLiteral 的形式提供。</li>
</ul>
</li>
<li><p>不允许修改和扩展任何原生对象和宿主对象的原型。</p>
</li>
<li><p>属性访问时，尽量使用 .。</p>
<ul>
<li>属性名符合 Identifier 的要求，就可以通过 . 来访问，否则就只能通过 [expr] 方式访问。</li>
</ul>
</li>
<li><p>for in 遍历对象时, 使用 hasOwnProperty 过滤掉原型中的属性。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newInfo = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (info.hasOwnProperty(key)) &#123;</span><br><span class="line">        newInfo[key] = info[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><p>使用数组字面量 [] 创建新数组，除非想要创建的是指定长度的数组。</p>
</li>
<li><p>遍历数组不使用 for in。</p>
<ul>
<li>数组对象可能存在数字意外的属性，这种情况下for in 不会得到正确的结果</li>
</ul>
</li>
<li><p>不因为性能的原因自己实现数组排序功能，尽量使用数组的sort方法</p>
<ul>
<li>自己实现的常规排序算法，在性能上并不优于数组默认的sort方法。以下场景可以自己实现排序:<ol>
<li>需要稳定的排序算法，达到严格一致的排序结果。</li>
<li>数据特点鲜明，适合使用桶排。</li>
</ol>
</li>
</ul>
</li>
<li><p>清空数组使用 .length = 0。</p>
</li>
</ul>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ol>
<li><p>函数长度</p>
<ul>
<li><p>一个函数的长度控制在50行以内</p>
<ul>
<li><p>将过多的逻辑单元混在一个大函数中，易导致难以维护。一个清晰易懂的函数应该完成单一的逻辑单元。复杂的操作应进一步抽取，通过函数的调用来体现流程。</p>
</li>
<li><p>特定算法等不可分割的逻辑允许例外。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>参数设计</p>
<ul>
<li><p>一个函数的参数控制在 6 个以内。</p>
<ul>
<li><p>除去不定长参数以外，函数具备不同逻辑意义的参数建议控制在 6 个以内，过多参数会导致维护难度增大。</p>
</li>
<li><p>某些情况下，如使用 AMD Loader 的 require 加载多个模块时，其 callback 可能会存在较多参数，因此对函数参数的个数不做强制限制。</p>
</li>
</ul>
</li>
<li><p>通过 options 参数传递非数据输入型参数。</p>
<ul>
<li>有些函数的参数并不是作为算法的输入，而是对算法的某些分支条件判断之用，此类参数建议通过一个 options 参数传递。</li>
</ul>
</li>
</ul>
</li>
<li><p>闭包</p>
<ul>
<li><p>在适当的时候将闭包内大对象置为 null。</p>
<ul>
<li><p>在JS中，无需特别的关键词就可以使用闭包，一个函数可以任意访问在其定义的作用于外的变量。需要注意的是，函数的作用域是静态的，即在定义时决定，与调用的时机和方式没有任何关系。</p>
</li>
<li><p>闭包会阻止一些变量的垃圾回收，对于较老旧的 JavaScript 引擎，可能导致外部所有变量均无法回收。</p>
</li>
<li><p>首先一个较为明确的结论是，以下内容会影响到闭包内变量的回收：</p>
<ul>
<li>嵌套的函数中是否有使用该变量。</li>
<li>嵌套的函数中是否有 直接调用eval。</li>
<li>是否使用了 with 表达式。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>空函数</p>
<ul>
<li><p>空函数不使用 new Function() 的形式。</p>
</li>
<li><p>对于性能有高要求的场合，建议存在一个空函数的常量，供多处使用共享。</p>
</li>
</ul>
</li>
</ol>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul>
<li>类的继承方案，实现时需要修正 constructor。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构建类之间的继承关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">    F.prototype = superClass.prototype;</span><br><span class="line">    subClass.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    subClass.prototype.constructor = subClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>声明类时，保证constructor的正确性</p>
</li>
<li><p>属性在构造函数中声明，方法在原型中声明。</p>
<ul>
<li>原型对象的成员被所有实例共享，能节约内存占用。所以编码时我们应该遵守这样的原则：原型对象包含程序不会修改的成员，如方法函数或配置项。</li>
</ul>
</li>
<li><p>自定义事件的 事件名 必须全小写。</p>
<ul>
<li>在 JavaScript 广泛应用的浏览器环境，绝大多数 DOM 事件名称都是全小写的。为了遵<br>循大多数 JavaScript 开发者的习惯，在设计自定义事件时，事件名也应该全小写。</li>
</ul>
</li>
<li><p>自定义事件只能有一个 event 参数。如果事件需要传递较多信息，应仔细设计事件对象。</p>
<ul>
<li><p>一个事件对象的好处有：</p>
<ol>
<li>顺序无关，避免事件监听者需要记忆参数顺序。</li>
<li>每个事件信息都可以根据需要提供或者不提供，更自由。</li>
<li>扩展方便，未来添加事件信息时，无需考虑会破坏监听器参数形式而无法向后兼容。</li>
</ol>
</li>
</ul>
</li>
<li><p>设计自定义事件时，应考虑禁止默认行为。</p>
<ul>
<li>常见禁止默认行为的方式有两种：<ul>
<li>事件监听函数中 return false。</li>
<li>事件对象中包含禁止默认行为的方法，如 preventDefault。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="动态特性"><a href="#动态特性" class="headerlink" title="动态特性"></a>动态特性</h4><ol>
<li><p>eval</p>
<ul>
<li><p>避免使用直接 eval 函数。</p>
<ul>
<li>直接 eval，指的是以函数方式调用 eval 的调用方法。直接 eval 调用执行代码的作用域为本地作用域，应当避免。</li>
</ul>
</li>
<li><p>尽量避免使用 eval 函数。</p>
</li>
</ul>
</li>
<li><p>动态执行代码</p>
<ul>
<li><p>使用 new Function 执行动态代码。</p>
<ul>
<li>通过 new Function 生成的函数作用域是全局使用域，不会影响当当前的本地作用域。如果有动态代码执行的需求，建议使用 new Function。</li>
</ul>
</li>
</ul>
</li>
<li><p>with</p>
<ul>
<li>尽量不要使用 with。</li>
</ul>
</li>
<li><p>delete</p>
<ul>
<li><p>减少 delete 的使用。（如果没有特别的需求，减少或避免使用 delete。delete 的使用会破坏部分 JavaScript 引擎的性能优化。）</p>
</li>
<li><p>处理 delete 可能产生的异常。</p>
<ul>
<li><p>对于有被遍历需求，且值 null 被认为具有业务逻辑意义的值的对象，移除某个属性必须使用 delete 操作。</p>
</li>
<li><p>在严格模式或 IE 下使用 delete 时，不能被删除的属性会抛出异常，因此在不确定属性是否可以删除的情况下，建议添加 try-catch 块。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对象属性</p>
<ul>
<li><p>避免修改外部传入的对象</p>
<ul>
<li><p>JavaScript 因其脚本语言的动态特性，当一个对象未被 seal 或 freeze 时，可以任意添加、删除、修改属性值。</p>
</li>
<li><p>但是随意地对 非自身控制的对象 进行修改，很容易造成代码在不可预知的情况下出现问题</p>
</li>
</ul>
</li>
<li><p>具备强类型的设计。</p>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/16/interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lurel">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laurel Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/16/interview/" itemprop="url">interview</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-16T15:37:27+08:00">
                2019-04-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Interview"><a href="#Interview" class="headerlink" title="Interview"></a>Interview</h3><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><ul>
<li><p>不采用缓存的目的是？如何实现？</p>
<ul>
<li><p>浏览器有一个临时的存储网站文件的缓存，所以他们不需要在切换或重新加载同一个页面时再次重新下载。服务器设置发送头信息告诉浏览器在给定的一段时间内使用存储文件。可极大加快网站的速度和节省带宽。</p>
</li>
<li><p>当网站更新时，因为用户的缓存依然指向旧文件，会造成问题。如果缓存的CSS和JS文件引用的元素不再存在，已移除或已重命名时，它会保留原有功能或破坏网站</p>
</li>
<li><p>禁用缓存是一个强制浏览器下载新文件的过程。通过命名来区分旧文件</p>
</li>
<li><p>常用的强制浏览器重新下载文件的技术是在文件的结尾处增加一个查询字符串：src=”js/script.js” =&gt; src=”js/script.js?v=2”</p>
</li>
</ul>
</li>
</ul>
<h4 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h4><ul>
<li><p>JS 的数据类型</p>
<ul>
<li>最新的ECMAScript定义了7种数据类型：<ul>
<li>原始数据类型：Boolean，Null，Undefined，Number，String，Symbol</li>
<li>引用数据类型：Object [Array, Date, Function, RegExp]</li>
</ul>
</li>
</ul>
</li>
<li><p>避免回调地狱</p>
<ul>
<li>使用async/await重构函数返回promise是最佳选择；返回一个promise，等待数据接受后然后解析，允许下一行代码以同步风格的方式进行。</li>
<li>模块化：把回调分割为独立函数</li>
<li>使用一个控制流的库，像async</li>
<li>使用一个带有promise的生成器</li>
<li>使用async/await（ES8及以上）</li>
</ul>
</li>
<li><p>什么是Promise</p>
<p>  Promise对象代表的是异步操作最终的完成(或失败)，和它的结果值。Promise是链式调用的。</p>
<ul>
<li>Promise的状态只能是其中之一：<ul>
<li>pending：初始状态，不是完成态(fulfilled)也不是拒绝态(rejected)</li>
<li>fulfilled：意味操作已经完成</li>
<li>rejected：意味操作已经失败</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是回调</p>
<p>  回调函数是作为一个参数传递给另一个函数的函数，只有在事件触发或具体任务完成时调用，经常用在异步代码中。回调函数会在一段代码之后调用，但可以在初始化声明，而不需要调用</p>
<p>  回调函数也可以是同步的。</p>
</li>
<li><p>JS中，如何比较两个对象</p>
<p>  即使两个相同属性相同值的不同对象，当使用 == 或 === 进行比较时，也不认为他们相等。因为他们都是通过引用比较的，不像基本类型是通过值比较的。</p>
<p>  提供一个辅助函数，它会迭代每个对象每个自己的属性，测试他们是否有相同的值</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDeepEqual</span>(<span class="params">obj1, obj2, testPrototype = false</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj1 === obj2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj1 === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> obj2 === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj1.toString() === obj2.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj1 <span class="keyword">instanceof</span> <span class="built_in">Date</span> &amp;&amp; obj2 <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj1.getTime() === obj2.getTime()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        <span class="built_in">Object</span>.prototype.toString.call(obj1) !== <span class="built_in">Object</span>.prototype.toString.call(obj2)</span><br><span class="line">        &amp;&amp; obj1 !== <span class="string">'object'</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> prototypeAreEqual = testPrototype</span><br><span class="line">        ? isDeepEqual(</span><br><span class="line">            <span class="built_in">Object</span>.getPrototypeOf(obj1),</span><br><span class="line">            <span class="built_in">Object</span>.getPrototypeOf(obj2),</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        )</span><br><span class="line">        : <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> obj1Props = <span class="built_in">Object</span>.getOwnPropertyNames(obj1)</span><br><span class="line">    <span class="keyword">const</span> obj2Props = <span class="built_in">Object</span>.getOwnPropertyNames(obj2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        obj1Props.length === obj2Props.length &amp;&amp;</span><br><span class="line">        prototypesAreEqual &amp;&amp;</span><br><span class="line">        obj1Props.every(<span class="function"><span class="params">prop</span> =&gt;</span> isDeepEqual(obj1[prop], obj2[prop]))</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/15/webpack中按需打包的babel插件实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lurel">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laurel Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/webpack中按需打包的babel插件实现/" itemprop="url">webpack中按需打包的babel插件实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-15T14:41:32+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="babel插件实现按需打包的功能"><a href="#babel插件实现按需打包的功能" class="headerlink" title="babel插件实现按需打包的功能"></a>babel插件实现按需打包的功能</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><blockquote>
</blockquote>
<pre><code>import {flatten,join} from &apos;lodash&apos;;

转化成=========&gt;

import flatten from &apos;lodash/flatten&apos;;
import join from &apos;lodash/join&apos;;
</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p>配置.babelrc</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"babel-plugin-sui-import"</span>, <span class="comment">// 这个是自己写的插件名</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"libraryName"</span>: <span class="string">"vant"</span>, <span class="comment">// 在引用哪个库时候使用自己写的这个插件</span></span><br><span class="line">                <span class="string">"libraryDirectory"</span>: <span class="string">"lib"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入脚本，进行对比</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#123;flatten,join&#125; from 'lodash' // 打包后大小：483k</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> flatten <span class="keyword">from</span> <span class="string">'lodash/flatten'</span> <span class="comment">// 打包后大小：21.3K</span></span><br><span class="line"><span class="keyword">import</span> join <span class="keyword">from</span> <span class="string">'lodash/join'</span></span><br></pre></td></tr></table></figure>
<p>  两种引入方式的抽象语法树的差别，只是IMportDeclaration不同</p>
</li>
<li><p>整理插件代码到node_modules文件中</p>
<p>  babel插件的文件名，必须以babel-plugin-xxx命名，否则引入不成功；babel插件返回的是一个对象，里面是个访问者模式的visitor对象，里面是转化代码</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> t = <span class="built_in">require</span>(<span class="string">'@babel/types'</span>);</span><br><span class="line"><span class="keyword">const</span> humps = <span class="built_in">require</span>(<span class="string">'humps'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        visitor: &#123;</span><br><span class="line">            ImportDeclaration(</span><br><span class="line">                path,</span><br><span class="line">                &#123;</span><br><span class="line">                opts: &#123; libraryName, libraryDirectory &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!t.isStringLiteral(path.node.source, &#123; <span class="attr">value</span>: libraryName &#125;)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">const</span> specifiers = path.node.specifiers;</span><br><span class="line">                <span class="keyword">const</span> declarations = specifiers.map(<span class="function"><span class="params">specifier</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> t.ImportDeclaration(</span><br><span class="line">                        [t.importDefaultSpecifier(specifier.local)],</span><br><span class="line">                        t.StringLiteral(</span><br><span class="line">                        <span class="string">`<span class="subst">$&#123;libraryName&#125;</span>/<span class="subst">$&#123;libraryDirectory&#125;</span>/<span class="subst">$&#123;humps.camelize(</span></span></span><br><span class="line"><span class="string"><span class="subst">                            specifier.local.name</span></span></span><br><span class="line"><span class="string"><span class="subst">                        )&#125;</span>`</span></span><br><span class="line">                        )</span><br><span class="line">                    );</span><br><span class="line">                &#125;);</span><br><span class="line">                path.replaceWithMultiple(declarations);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/15/webpack多入口文件页面配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lurel">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laurel Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/webpack多入口文件页面配置/" itemprop="url">webpack多入口文件页面配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-15T11:27:39+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index">
                    <span itemprop="name">interview</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="webpack多入口文件页面配置"><a href="#webpack多入口文件页面配置" class="headerlink" title="webpack多入口文件页面配置"></a>webpack多入口文件页面配置</h2><p>webpack的多页面文件的打包配置</p>
<pre><code>单页应用程序和多页应用程序的webpack配置文件绝大部分是相同的，loader、output、plugins这些基本不需改动；

需要改动的一般都是入口文件entry，如果用到抽离css样式的插件extract-text-webpack-plugin、自动模板插件html-webpack-plugin,需要进行额外的改写。
</code></pre><ul>
<li><p>entry</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多页应用程序，则需要多个入口文件(如：项目里有多个入口文件)</span></span><br><span class="line">entry: &#123;</span><br><span class="line">    home: resolve(__dirname, <span class="string">'src/home/index.js'</span>),</span><br><span class="line">    about: resolve(__dirname, <span class="string">'src/about/index.js'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>extract-text-webpack-plugin</p>
<p>  主要是为了抽离css样式，防止将样式打包在js中引起页面样式加载错乱或者js脚本体积过大等情况；</p>
<ol>
<li><p>多页程序，因为存在多个入口文件以及对应的多个页面，每个页面都有自己的css样式，所以需要为每个页面各自配置:</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为每个页面定义一个 ExtractTextPlugin</span></span><br><span class="line"><span class="keyword">const</span> homeExtractCss = <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'home/[name].[contenthash].css'</span>)</span><br><span class="line"><span class="keyword">const</span> aboutExtractCss = <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'about/[name].[contenthash].css'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多页应用程序，则需要多个入口文件(如：项目里有多个入口文件)</span></span><br><span class="line">plugins: [</span><br><span class="line">    homeExtractCss</span><br><span class="line">    aboutExtractCss</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个页面只需要知己的css样式，不需要别的页面css样式，以防样式覆盖和代码冗余，需要对loader配置进行修改：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [ <span class="comment">// 每个页面的 ExtractTextPlugin 只处理这个页面的样式文件</span></span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/src(\\|\/)home(\\|\/)css(\\|\/).*\.(css|scss)$/</span>,</span><br><span class="line">            use: homeExtractCss.extract(&#123;</span><br><span class="line">                fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">                use: [<span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,  &#123;</span><br><span class="line">            test: <span class="regexp">/src(\\|\/)about(\\|\/)css(\\|\/).*\.(css|scss)$/</span>,</span><br><span class="line">            use: aboutExtractCss.extract(&#123;</span><br><span class="line">                fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">                use: [<span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每个页面都有各自的 ExtractTextPlugin，所以需要都声明一遍</span></span><br><span class="line">plugins: [homeExtractCss, aboutExtractCss]</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>html-webpack-plugin<br>  在单页应用程序和多页应用程序中的 webpack配置没什么区别，有几个页面，就对每个页面进行配置即可</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'about/about.html'</span>, <span class="comment">// 'home/home.html'</span></span><br><span class="line">    template: <span class="string">'src/about/html/index.html'</span>, <span class="comment">// 'src/about/html/index.html'</span></span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">    minify: &#123;</span><br><span class="line">        removeComments: <span class="literal">true</span>,</span><br><span class="line">        collapseWhitespace: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动配置<br>  每个页面都是 src/目录下的一个文件夹，这个文件夹中有两个子目录，分别存放这个页面的模板 html，样式文件 css，还有一个入口文件 index.js</p>
<p>  通过一个通用方法来获取所有的页面名称（每个页面都是 ./src下的一个目录，目录名即为页面名）：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEntry</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 借助glob库，遍历.src/目录下具有这种规律src/**/html/*.html的子目录，通过正则匹配出子目录的名称</span></span><br><span class="line">    <span class="keyword">let</span> globPath = <span class="string">'src/**/html/*.html'</span></span><br><span class="line">    <span class="comment">// (\/|\\\\) 这种写法是为了兼容 windows和 mac系统目录路径的不同写法</span></span><br><span class="line">    <span class="keyword">let</span> pathDir = <span class="string">'src(\/|\\\\)(.*?)(\/|\\\\)html'</span></span><br><span class="line">    <span class="keyword">let</span> files = glob.sync(globPath)</span><br><span class="line">    <span class="keyword">let</span> dirname, entries = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">        dirname = path.dirname(files[i])</span><br><span class="line">        entries.push(dirname.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^'</span> + pathDir), <span class="string">'$2'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entries</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/12/vue中computed分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lurel">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laurel Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/vue中computed分析/" itemprop="url">vue中computed分析&vuex原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-12T17:22:44+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="vuex原理"><a href="#vuex原理" class="headerlink" title="vuex原理"></a>vuex原理</h3><p>vuex依赖于vue的computed依赖检测系统以及插件系统</p>
<p>Vuex.store除了初始化以外还有重置VM方法，即resetStoreVM(this, state).<br>本质是将传入的state作为一个隐藏的vue组件的data，commit操作本质是修改这个组件的data值。结合computed，修改被defineReactive代理的对象值后，会将其收集到的依赖的watcher中的dirty设置为true，等下一次访问该watcher中的值后重新获取最新值。可推出：store._vm.$data.$$state === store.state</p>
<p>vuex的实现方式使用了vue自身的响应式设计，依赖监听、依赖收集都属于vue对对象Property set get方式的代理劫持。即vuex工作原理：vuex中的store本质就是没有template的隐藏着的vue组件</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><ul>
<li>计算属性如何与属性建立依赖关系</li>
<li>属性发生变化如何通知到计算属性重新计算</li>
</ul>
<p>依赖收集、动态计算的流程：</p>
<ol>
<li>data属性初始化getter setter</li>
<li>computed 计算属性初始化，提供的函数用作属性(vm.reverseMsg)的getter</li>
<li>当首次获取计算属性(vm.reverseMsg)的值时，Dep开始依赖收集</li>
<li>在执行msg getter方法时，如果Dep处于依赖收集状态，则判定 msg为reverseMsg的依赖，并建立依赖关系</li>
<li>当 msg 发生变化时，根据依赖关系，触发 reverseMsg 的重新计算。</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li><p>初始化组件的state方法：initState</p>
<ul>
<li>当组件实例化时会自动触发，主要完成了初始化data、props、computed、watch等属性，以及initData和initComputed</li>
<li><p>initData</p>
<ul>
<li>将vue的data传入observer方法（该方法本质是实例化了一个Observer对象）</li>
<li>Observer里的重点：new Dep对象；给data的所有属性调用defineReactive</li>
<li>defineReactive是vue实现 MDV(Model-Driven-View)的基础，就是代理数据的get，set方法。当数据修改或获取的时候，能够感知<ul>
<li>在给具体属性调用defineReactive方法时，都会为该属性生成唯一的dep对象。</li>
<li>重新定义data当中的属性，对get和set进行代理</li>
<li>get里收集依赖，dep.depend() // reversedMessage为什么会跟着message变化的原因<ul>
<li>dep.depend()是将该dep加入watcher的newDeps中,同时将所访问当前属性的dep对象中的subs插入当前Dep.target的watcher</li>
</ul>
</li>
<li>set里通知依赖进行更新，dep.notify()<ul>
<li>notify方法即将加入该dep的watcher全部更新，即当修改data中某个属性值时，会同时调用dep.notify()来更新依赖该值的所有watcher</li>
</ul>
</li>
</ul>
</li>
<li>Dep 是 vue 实现的一个处理依赖关系的对象，主要起到一个纽带的作用，就是连接 reactive data 与 watcher<ul>
<li>重点方法：addSub()；depend()；notify() // 更新watcher 的值</li>
<li>当首次计算 computed 属性的值时，Dep 将会在计算期间对依赖进行收集</li>
<li>pushTarget：在一次依赖收集期间，如果有其他依赖收集任务开始，将会把当前 target 暂存到 targetStack，先进行其他 target 的依赖收集，</li>
<li>popTarget: 当嵌套的依赖收集任务完成后，将 target 恢复为上一层的 Watcher，并继续做依赖收集</li>
</ul>
</li>
</ul>
</li>
<li><p>initComputed</p>
<ul>
<li>对每一个属性都生成了一个属于自己的Watcher实例，并将 { lazy: true }作为options传入<ul>
<li>在computed生成的watcher，会将watcher的lazy设置为true,以减少计算量。因此，实例化时，this.dirty也是true,标明数据需要更新操作</li>
<li>先记住现在computed中初始化对各个属性生成的watcher的dirty和lazy都设置为了true。同时，将computed传入的属性值（一般为funtion）,放入watcher的getter中保存起来。</li>
</ul>
</li>
<li>对每一个属性调用了defineComputed方法(本质和data一样，代理了自己的set和get方法)<ul>
<li>当第一次访问computed中的值时，会因为初始化watcher.dirty = watcher.lazy的原因，从而调用watcher.evalute()方法，evalute()方法就是调用了watcher实例中的get方法以及设置dirty = false,我们将这两个方法放在一起<ul>
<li>get方法： 调用了pushTarget方法，其作用就是将Dep.target设置为所传入的watcher,即所访问的computed中属性的watcher</li>
<li>this.getter 在Watcher构建函数中提到，本质就是用户传入的方法，也就是说，this.getter.call(vm, vm)就会调用用户自己声明的方法，那么如果方法里面用到了 this.data中的值或者其他被用defineReactive包装过的对象，那么，访问this.data.或者其他被defineReactive包装过的属性，是不是就会访问被代理的该属性的get方法（computed的watcher依赖了this.data的dep）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>拆解获取依赖并更新的过程：</p>
<ul>
<li>初始化 data和computed，分别代理其get和set方法，对data中的所有属性生成唯一的dep实例</li>
<li>对computed中的属性A生成唯一的watcher，并保存到vm._computedWatchers中</li>
<li>访问计算属性A，设置Dep.target指向计算属性A的watcher，调用该属性具体的方法A()</li>
<li>方法中访问属性this.a，即会调用this.a代理的get方法，将this.a的dep加入计算属性A的watcher，同时该dep中的subs添加这个watcher</li>
<li>设置vm.a = ‘new a’，调用a代理的set方法触发dep的notify方法</li>
<li>因为是computed属性，只是将watcher中的dirty设置为true</li>
<li>查询计算属性vm.A，访问其get方法时，得知计算属性A的watcher.dirty为true,调用watcher.evaluate()方法获取新的值。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/12/webpack-loader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lurel">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laurel Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/webpack-loader/" itemprop="url">webpack-loader</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-12T17:20:22+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>(<a href="https://webpack.docschina.org/loaders/" target="_blank" rel="noopener">https://webpack.docschina.org/loaders/</a>)</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>webpack可以使用loader来预处理文件，允许打包除JS之外的文件。用于对模块的源代码进行转换。<br>loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript 或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！</p>
<p>类型：</p>
<ul>
<li>文件：<ul>
<li>raw-loader：加载文件原始内容（utf-8）</li>
<li>val-loader： 将代码作为模块执行，并将 exports 转为 JS 代码</li>
<li>file-loader： 将文件发送到输出文件夹，并返回（相对）URL</li>
<li>url-loader 像 file loader 一样工作，但如果文件小于字节限制，可以返回 data URL</li>
<li>ref-loader 手动创建所有文件之间的依赖关系</li>
</ul>
</li>
<li>JSON：<ul>
<li>json-loader 加载 JSON 文件（默认包含）</li>
<li>json5-loader 加载和转译 JSON 5 文件</li>
<li>cson-loader 加载和转译 CSON 文件</li>
</ul>
</li>
<li>转译(transpiling)<ul>
<li>script-loader: 在全局上下文中执行一次 JavaScript 文件（如在 script 标签），不需要解析</li>
<li>babel-loader 加载 ES2015+ 代码，然后使用 Babel 转译为 ES5</li>
<li>buble-loader 使用 Bublé 加载 ES2015+ 代码，并且将代码转译为 ES5</li>
<li>traceur-loader 加载 ES2015+ 代码，然后使用 Traceur 转译为 ES5</li>
<li>ts-loader 或 awesome-typescript-loader 像 JavaScript 一样加载TypeScript 2.0+</li>
<li>coffee-loader 像 JavaScript 一样加载 CoffeeScript</li>
<li>fengari-loader 使用 fengari 加载 Lua 代码</li>
</ul>
</li>
<li>模板(templating)<ul>
<li>html-loader：导出html为字符串，需要引用静态资源</li>
<li>pug-loader：加载Pug模板并返回一个函数</li>
<li>markdown-loader：将markdown转译为HTML</li>
<li>react-markdown-loader 使用 markdown-parse parser(解析器) 将 Markdown 编译为 React 组件</li>
<li>posthtml-loader 使用 PostHTML 加载并转换 HTML 文件</li>
<li>handlebars-loader 将 Handlebars 转移为 HTML</li>
<li>markup-inline-loader 将内联的 SVG/MathML 文件转换为 HTML。在应用于图标字体，或将 CSS 动画应用于 SVG 时非常有用。</li>
<li>twig-loader 编译 Twig 模板，然后返回一个函数</li>
</ul>
</li>
<li>样式：<ul>
<li>style-loader 将模块的导出作为样式添加到 DOM 中</li>
<li>css-loader 解析 CSS 文件后，使用 import 加载，并且返回 CSS 代码</li>
<li>less-loader 加载和转译 LESS 文件</li>
<li>sass-loader 加载和转译 SASS/SCSS 文件</li>
<li>postcss-loader 使用 PostCSS 加载和转译 CSS/SSS 文件</li>
<li>stylus-loader 加载和转译 Stylus 文件</li>
</ul>
</li>
<li>代码检查和测试(linting &amp;&amp; testing)<ul>
<li>mocha-loader 使用 mocha 测试（浏览器/NodeJS）</li>
<li>eslint-loader PreLoader，使用 ESLint 清理代码</li>
<li>jshint-loader PreLoader，使用 JSHint 清理代码</li>
<li>jscs-loader PreLoader，使用 JSCS 检查代码样式</li>
<li>coverjs-loader PreLoader，使用 CoverJS 确定测试覆盖率</li>
</ul>
</li>
<li>框架(frameworks)<ul>
<li>vue-loader 加载和转译 Vue 组件</li>
<li>polymer-loader 使用选择预处理器(preprocessor)处理，并且 require() 类似一等模块(first-class)的 Web 组件</li>
<li>angular2-template-loader 加载和转译 Angular 组件</li>
</ul>
</li>
</ul>
<h3 id="使用loader（3种方式）"><a href="#使用loader（3种方式）" class="headerlink" title="使用loader（3种方式）"></a>使用loader（3种方式）</h3><ol>
<li>配置：在 webpack.config.js 文件中指定 loader。<ul>
<li>module.rules 允许你在 webpack 配置中指定多个 loader。<ul>
<li>rules：数组，指明各个loader。它会作用于匹配到 test 属性所指定规则的每一个文件</li>
<li>use：use 指明需要对匹配的文件应用那个loader</li>
</ul>
</li>
<li>loader 从右到左地取值(evaluate)/执行(execute)</li>
</ul>
</li>
<li>内联：在每个 import 语句中显式指定 loader。<ul>
<li>import Styles from ‘style-loader!css-loader?modules!./styles.css’;</li>
<li>使用 ! 将资源中的 loader 分开。每个部分都会相对于当前目录解析。</li>
</ul>
</li>
<li>CLI：在 shell 命令中指定它们<ul>
<li>webpack –module-bind jade-loader –module-bind ‘css=style-loader!css-loader’</li>
</ul>
</li>
</ol>
<h3 id="loader特性"><a href="#loader特性" class="headerlink" title="loader特性"></a>loader特性</h3><ul>
<li>loader 支持链式传递。链中的每个 loader 会将转换应用在已处理过的资源上。一组链式的 loader 将按照相反的顺序执行。链中的第一个 loader 将其结果（也就是应用过转换后的资源）传递给下一个 loader，依此类推。最后，链中的最后一个 loader，返回 webpack 期望 JavaScript。</li>
<li>loader 可以是同步的，也可以是异步的。</li>
<li>loader 运行在 Node.js 中，并且能够执行任何 Node.js 能做到的操作。</li>
<li>loader 可以通过 options 对象配置（仍然支持使用 query 参数来设置选项，但是这种方式已被废弃）。</li>
<li>除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块。</li>
<li>插件(plugin)可以为 loader 带来更多特性。</li>
<li>loader 能够产生额外的任意文件。</li>
</ul>
<h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p>允许你使用 Babel 和 webpack 转译 JavaScript 文件。<br>安装：npm install -D babel-loader @babel/core @babel/preset-env webpack</p>
<p>使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123; <span class="comment">// 向 loader 传递 options 选项：</span></span><br><span class="line">          presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优化：</p>
<ul>
<li><p>解决babel-loader很慢</p>
<ul>
<li><p>确保转译尽可能少的文件</p>
</li>
<li><p>使用exclude排除不需要的源代码</p>
</li>
<li><p>使用 <code>cacheDirectory</code> 选项，会将转译的结果缓存到文件系统中。</p>
</li>
</ul>
</li>
<li>Babel 在每个文件都插入了辅助代码，使代码体积过大<ul>
<li>Babel对一些公共方法使用了非常小的辅助代码(如 _extend)。默认情况下会被添加到每一个需要它的文件中,而babel-runtime供编译模块复用工具函数</li>
<li>可以引入Babel runtime作为一个独立模块，来避免重复引入</li>
<li>禁用Babe自动对每个文件的runtime注入，而是引入 @babel/plugin-transform-runtime 并且使所有辅助代码从这里引用</li>
</ul>
</li>
<li>transform-runtime &amp; babel-polyfill<ul>
<li>Babel默认只转换新的JS语法，而不转换新的 API(如：Object.assign)，使用 babel-polyfill，转译新的API</li>
<li>Babel 转译后的代码要实现源代码同样的功能需要借助一些帮助函数，可能会重复出现在一些模块里，导致编译后的代码体积变大，webpack提供了单独的包 babel-runtime 供编译模块复用工具函数<ul>
<li>babel 还为源代码的非实例方法和babel-runtime/helps 下的工具函数自动引用了 polyfill。这样可以避免污染全局命名空间，非常适合于 JavaScript 库和工具包的实现</li>
</ul>
</li>
<li>总结：<ul>
<li>具体项目还是需要使用 babel-polyfill，只使用 babel-runtime 的话，实例方法不能正常工作</li>
<li>JS库和工具可以使用 babel-runtime，在实际项目中使用这些库和工具，需要该项目本身提供polyfill；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>自定义loader：</p>
<pre><code>- babel-loader 提供了一个 loader-builder 工具函数，允许用户为 Babel 处理过的每个文件添加自定义处理选项。
</code></pre><h3 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h3><p>css-loader解释@import和url()并解析它们<br>安装：npm install –save-dev css-loader</p>
<h3 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h3><p>加载Sass/Scss文件并且编译成CSS，依赖node-sass<br>安装:npm install sass-loader node-sass webpack –save-dev</p>
<p>使用:</p>
<ul>
<li><p>通过将 style-loader 和 css-loader 与 sass-loader 链式调用，可以立刻将样式作用在 DOM 元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            <span class="string">"style-loader"</span>, <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">            <span class="string">"css-loader"</span>, <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">            <span class="string">"sass-loader"</span> <span class="comment">// 将 Sass 编译成 CSS，默认使用 Node Sass</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生产环境下通常使用mini-css-extract-plugin将样式表抽里程专门的单独文件。</p>
</li>
<li>提取样式表：extract-loader；mini-css-extract-plugin</li>
</ul>
<h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><p>file-loader将文件上的import/require()解析为url，并将文件发送到输出目录中。</p>
<ul>
<li>默认情况下，生成文件的文件名，是文件内容的 MD5 哈希值，并会保留所引用资源的原始扩展名</li>
<li>选项：<ul>
<li>name：为目标文件指定自定义文件名模板</li>
<li>outputPath： 指定放置目标文件的文件系统路径</li>
<li>publicPath：指定目标文件的自定义公共路径</li>
<li>context：指定自定义文件上下文</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/12/ServiceWorker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lurel">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laurel Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/ServiceWorker/" itemprop="url">ServiceWorker</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-12T17:17:04+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Service-Worker-生命周期"><a href="#Service-Worker-生命周期" class="headerlink" title="Service Worker 生命周期"></a>Service Worker 生命周期</h3><pre><code>Service Worker 脚本通过 navigator.serviceWorker.register 方法注册到页面。Service Worker 从注册开始需要先 install, 如果 install 成功, 接下来需要 activate, 然后才能接管页面。但是如果页面被先前的 Service Worker 控制着, 那么它会停留在 installed(waiting) 这个阶段等到页面重新打开才会接管页面, 或者可以通过调用 self.skipWaiting() 方法跳过等待
</code></pre><ul>
<li>过程：<ul>
<li>parsed：注册完成，脚本解析成功，尚未安装</li>
<li>installing：对应Service Worker脚本install事件，如果事件里有event.waitUntil()则会等待传入的Promise完成才会成功</li>
<li>installed(waiting): 页面被旧的 Service Worker 脚本控制, 所以当前的脚本尚未激活。可以通过 self.skipWaiting() 激活新的 Service Worker</li>
<li>activating: 对应 Service Worker 脚本 activate 事件执行, 如果事件里有 event.waitUntil() 则会等待这个 Promise 完成才会成功。这时可以调用 Clients.claim() 接管页面</li>
<li>activated: 激活成功, 可以处理 fetch, message 等事件</li>
<li>redundant: 安装失败, 或者激活失败, 或者被新的 Service Worker 替代掉</li>
</ul>
</li>
</ul>
<pre><code>Service Worker脚本最常用的功能是截获请求和缓存资源文件，可绑定在这些事件上：

- install事件中，抓取资源进行缓存；
- activate事件中，遍历缓存，清除过期的资源；
- fetch事件中，拦截请求，查询缓存或网络，返回请求的资源。
</code></pre><ol>
<li>缓存策略：<br> 处在 activated 状态的 Service Worker 可以拦截作用范围下的页面的网络请求, 由 Service Worker 监听 fetch 事件来决定请求如何响应</li>
</ol>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><pre><code>self: 表示 Service Worker 作用域, 也是全局变量
caches: 表示缓存，用来缓存外部资源
skipWaiting: 表示强制当前处在 waiting 状态的脚本进入 activate 状态
clients: 表示 Service Worker 接管的页面
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/12/Node内存泄露/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lurel">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laurel Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/Node内存泄露/" itemprop="url">Node内存泄露</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-12T17:14:51+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Node内存泄露"><a href="#Node内存泄露" class="headerlink" title="Node内存泄露"></a>Node内存泄露</h3><ul>
<li><p>问题：</p>
<p>  我们的应用中有时响应会很慢，甚至没有响应</p>
<p>  每天访问量在特定时间段会有大范围波动，但是整体比较平稳 。</p>
</li>
<li><p>分析：</p>
<p>  正常情况下node发起的请求，服务端就会有响应，最后吐给前端</p>
<p>  利用inspect反复分析内存，经过代码追踪，请求受阻，settimeout 代码不执行，被挂起，无法释放</p>
<p>  axios 超时</p>
</li>
</ul>
<pre><code>对于node来说，（代码块被挂起）cpu上升的原因有：settimeout，IO阻塞，express没调用res.end()结束请求。

压测后发现的现象：在服务器超载的情况下，由于无法做出响应，客户端的socket就会被挂起一直处于connection状态。
</code></pre><ul>
<li><p>结论：</p>
<p>  有时，响应会很慢，并且没有响应，就是连接事件将被事件循环系统阻塞。</p>
<p>  由于Node中，io链接会阻塞timer处理，因此这个setTimeout不会按时触发，也就有了超过了设定的超时时间以上才返回的情况。阻塞的connection导致请求堆积，服务器处理不过来，CPU也就下不来。</p>
</li>
</ul>
<ul>
<li>解决：</li>
</ul>
<p>利用socket中对于connect的超时处理来代替会在Nodejs中被阻塞的setTimeout来处理超时请求。</p>
<p>另一个暴力方案，采用pm2 start app.js –max-memory-restart 20M，声明应用在超过使用内存上限后自动重启</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在vue-ssr中造成内存和cpu泄露的原因：</p>
<ul>
<li>挂起的socket造成的暂时性的堵塞</li>
<li>vue-router中的timer在某些情况下会陷入死循环</li>
<li>大量的模板编译，内存中会存留大量被字符串占用的内存</li>
</ul>
<p>解决方案：</p>
<ul>
<li>移除component中对于beforeRouteEnter的处理。将这里的处理移到其他地方，从vue-router代码层面分析是可以避免陷入timer的死循环的。</li>
<li>在nodejs中替换掉setTimeout的方式去处理服务器端请求超时，改用http.request的timeout事件handle来处理。防止io阻塞timer处理。</li>
<li>如果不是对seo要求过高，采用骨架页渲染的方式，向客户端渲染出骨架页，然后由前端直接发起ajax请求拉取服务器数据。避免在nodejs端执行服务端请求由于服务端后台无法响应造成堵塞导致部分链接被挂起。（nodejs的事件循环和浏览器是不同的，虽然都是基于V8引擎。这也是大部分国内互联网公司在vue-ssr这块的普遍应用方式）</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/12/RPC-REST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lurel">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laurel Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/RPC-REST/" itemprop="url">RPC-REST</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-12T16:39:31+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/server/" itemprop="url" rel="index">
                    <span itemprop="name">server</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>远程调用框架（Remote Procedure Call），被调用方法的具体实现不在程序运行本地，而是在别的某个远程地方</p>
<ol>
<li>远程调用原理： A (client) 调用 B (server) 提供的方法<ul>
<li>首先A与B之间建立一个TCP连接；</li>
<li>然后A把需要调用的方法名以及方法参数序列化成字节流发送出去；</li>
<li>B接受A发送过来的字节流，然后反序列化得到目标方法名，方法参数，接着执行相应的方法调用并把结果返回；</li>
<li>A接受远程调用结果,输出结果</li>
</ul>
</li>
</ol>
<p><strong>RPC框架就是把这几点细节给封装起来，给用户暴露简单友好的API使用</strong></p>
<ol>
<li><p>好处：</p>
<p> 解耦：当server需要对方法内实现修改时，client完全感知不到，不用做任何变更；这种方式在跨部门，跨公司合作的时候经常用到，并且方法的提供者我们通常称为：服务的暴露</p>
</li>
</ol>
<h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>​    RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计</p>
<p>​    REST – REpresentational State Transfer：表现层状态转移。资源在网络中以某种表现形式进行状态转移。分解开来：</p>
<ul>
<li><p>​Resource：资源，即数据（前面说过网络的核心）。比如 newsfeed，friends等；</p>
</li>
<li><p>Representational：某种表现形式，比如用JSON，XML，JPEG等；</p>
</li>
<li>State Transfer：状态变化。通过HTTP动词实现。</li>
</ul>
<h3 id="URL设计"><a href="#URL设计" class="headerlink" title="URL设计"></a>URL设计</h3><ol>
<li><p>RESTful 的核心思想是客户端发出的数据操作指令都是”动词 + 宾语”的结构</p>
<p> 动词通常就是五种 HTTP 方法，对应 CRUD 操作：</p>
<ul>
<li><p>GET：读取（Read）</p>
</li>
<li><p>POST：新建（Create）</p>
</li>
<li><p>PUT：更新（Update）</p>
</li>
<li><p>PATCH：更新（Update），通常是部分更新</p>
</li>
<li><p>DELETE：删除（Delete）</p>
</li>
</ul>
</li>
</ol>
<pre><code>宾语就是 API 的 URL，是 HTTP 动词作用的对象。
</code></pre><ol>
<li><p>状态码必须精确</p>
<p> HTTP状态码，分5个类别：</p>
<ul>
<li>1xx：相关信息</li>
<li>2xx：操作成功</li>
<li>3xx：重定向</li>
<li>4xx：客户端错误</li>
<li>5xx：服务器错误</li>
</ul>
</li>
<li><p>服务器回应</p>
<ul>
<li>API 返回的数据格式不应是纯本文，而应该是一个 JSON 对象（Content-Type属性设为application/json）</li>
<li>发生错误时，不要返回 200 状态码：状态码反映发生的错误，具体的错误信息放在数据体里面返回</li>
<li>提供链接：API 的使用者未必知道，URL 是怎么设计的。解决方法就是，在回应中，给出相关链接，便于下一步操作</li>
</ul>
</li>
</ol>
<h2 id="RPC与REST有什么区别"><a href="#RPC与REST有什么区别" class="headerlink" title="RPC与REST有什么区别"></a>RPC与REST有什么区别</h2><p>RPC是client/server模式的，调用远程的方法，REST也是一套API调用协议方法，它也是基于client/server模式的，调用远程的方法的。</p>
<p>REST API 和 RPC 都是在 Server端 把一个个函数封装成接口暴露出去，以供 Client端 调用，但REST API 是基于HTTP协议的，REST致力于通过http协议中的POST/GET/PUT/DELETE等方法和一个可读性强的URL来提供一个http请求。而 RPC 则可以不基于 HTTP协议<br>因此，如果是后端两种语言互相调用，用 RPC 可以获得更好的性能（省去了 HTTP 报头等一系列东西），应该也更容易配置</p>
<p>Link:</p>
<ul>
<li><p><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html</a></p>
</li>
<li><p><a href="https://blog.csdn.net/cs958903980/article/details/78674087" target="_blank" rel="noopener">https://blog.csdn.net/cs958903980/article/details/78674087</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lurel</p>
              <p class="site-description motion-element" itemprop="description">desc</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">Kategorien</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">Tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lurel</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
